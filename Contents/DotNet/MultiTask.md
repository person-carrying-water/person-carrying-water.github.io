---
layout: default
title: ":eyeglasses: .NET(C#、VB.NET、C++/CLI、F#)"
description: ":black_nib: .NETにおける並行、並列処理について"
date: "2020/05/17"
lastmod: "2020/05/17"
---

## 0. 概要

-   #### `プロセス`
    OSからメモリーの割り当てを受けて動作するプログラムの実行単位。アプリケーションを実行すると1つ以上のプロセスが起動される。  

-   #### `スレッド`
    プロセス内の処理の流れ。1プロセスは1つ以上のスレッドから構成される。  
    1プロセス内で複数の処理の流れを作り並行、並列して処理を進める事をマルチスレッドと言う。  
    GUIプログラムにおいて1つ目の起動された時にできるスレッドをUIスレッドと言う。  
    そこから、別スレッドを走らせたものをワーカースレッドと言う。    

-   #### `タスク`
    OSの実行単位という意味を持ちいろんな使われ方がある。  
    プロセスとほぼ同じ意味を持ったり、処理の流れのスレッドとほぼ同じ意味での使われ方もある。  
    複数のタスク(プロセスレベル)を切り替えて実行できるシステムをマルチタスク(プロセス)という。  
    .NETでは、非同期に呼び出されるスレッド(Taskクラス)の単位の事を指す場合もある。

-   #### `並行処理`
    複数のスレッドが切り替え動作しており、同時には実行されていない状態を言う。  
    例えば、シングルコア上でマルチスレッドを動作させた場合、ある瞬間は１コアしかないので１つの動作しか行えない。  
    プロセッサが実行リソースを各スレッドに順次高速に切り替えて割り当て処理をする事により同時実行されているように見える状態を言う。  
    また、順次処理される順番は不定。スレッド１の処理1-1と処理1-2、スレッド２の処理2-1と処理2-2があったとする。  
    処理1-1→処理2-1→処理1-2→処理2-1で処理されるかもしれないし、処理1-1→処理1-2→処理2-1→処理2-2で処理されるかもしれない。  

-   #### `並列処理`
    複数のスレッドが同時に実行される状態を言う。  
    共有メモリー方式のマルチコア上でマルチスレッドを動作させた場合、各スレッドがそれぞれ別コア上で動作するため並列処理となる。  
    並行処理とは違い同時に実行されるのですべての命令を完了させるためのトータル時間は短くなる(1つの処理にかかる時間は同じ)。  
    プロセス内のスレッド数が利用可能なコア数以下の場合は、OSのスレッドサポートシステムによって各スレッドがそれぞれのコアで  
    動作する事を保証している。例えば、4コアの場合は4スレッドまでは同時実行(並列処理)される。  
    それ以上のスレッドを実行した場合は並行処理(短時間でスレッドを切り替える)で行われる。  

-   #### `ハイパースレッディング`

-   #### `同期`
    １つのタスク(プロセスやスレッド)が実行している間、他のタスクは中断し実行中のタスクが完了するまで待つ方式。  
    また、複数のタスクはタイミングを取っている事。  

-   #### `非同期`
    １つのタスク(プロセスやスレッド)を実行している間も他のタスクを実行できる方式  
    複数のスレッドで変数を共有する場合、１つのスレッドで読み書き両方を行わず読み込みだけ行い、書き込む前に他のスレッドが読み込みを  
    行うと条件によっては誤った処理をしてしまったり、問答無用で上書きしてしまう場合どちらが先に上書きされるか分からないので考慮する必要がある。  

-   #### `スレッドプール`

-   #### `スレッドセーフ`

-   #### `排他制御`

-   #### `デッドロック`

<br />

## 1. GUIアプリケーションでのループ処理の注意

1-1. 監視プログラムのようなループをひたすら回すような場合は、async/await(Task)で非同期処理とし、  
GUIをアクティブの状態(UIスレッドは受け付けるようにする)にし、別スレッドでループ監視を行う。  
※ただし、Taskを起動する命令から後ろの処理は行われない(awaitを外すと後ろの処理は行われる)。  

1-2. System.Windows.Forms.Application.DoEvents()などのWindowsメッセージキューの取り出し(CPUの開放も兼ねる)は、  
そのまま使うとパフォーマンスが悪く非常に時間が掛かる場合がある(100ms～500msなどの時間を要する事もある)。  
よって事実上は別スレッドからInvoke()メソッドを使いGUIにアクセスする方法が現実的。  
また、DoEvents()はメッセージキューのすべての取り出しを行う様で、これでは無くWinAPIのGetInputStatus()を使う手もある様だが  
実際に試した事が無いのでその効果は分からない。または他のWinAPIでは何かあるか。    

<br />

## 2 無限ループや無限ループではないが長時間ループし続ける処理を行う場合

無限ループはかなり重くなるので１つが理想だが、１つで済まない場合でも数個以内にする。  

この様な無限ループは、アプリケーションソフト全体の処理を占有する。  
よってループによる処理以外は、その他のアプリケーションソフトは何も行えなくなる。  
また、ループが回っている間でも、本来はイベントメッセージの処理を行う必要もある。  
しかし、ループが回っている間はイベントメッセージがメッセージキューに溜まったままで何も行えない。  
よって、アプリケーションソフトが固まって動かなくなったり異常が発生する。  
そこでDoEvents()などのメッセージキューを処理する方法があるがこれではパフォーマンスが悪い。  
なのでマルチスレッド化になる訳だがその別スレッドを処理するコアのCPU使用率は占有される。  
よって対策としてはSystem.Threading.Thread.Sleep()などのスリープ処理を入れCPUを休ませる必要がある。  
その他の方法があれば良いが今の所はこれだけ。  

**良し悪しは別として何かを監視(定期的にチェック)するプログラムの３の方法**  
1. 無限ループ内でマルチスレッド化する。  
ループ処理を、Main処理とは別スレッドで並列に処理させればMain処理に悪影響を与えない。  

2.  無限ループではなくタイマーを活用する。  
    タイマーは、定期時間ごとに毎回起動する処理の方法。  

3.  メッセージループを使用。  
    Windowsであるなら、メッセージループを使用。  

* * *
