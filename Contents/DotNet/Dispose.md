---
layout: default
title: ":eyeglasses: .NET(C#、VB.NET、C++/CLI、F#)"
description: ":black_nib: .NETにおけるオブジェクトの破棄とメモリーの解放"
date: "2020/05/17"
lastmod: "2020/05/17"
---

## 1. 用語

### ガベージコレクション

メモリーの参照が行われていないと判断されたオブジェクトを自動で破棄、メモリーの解放を行う。  
ただし、この機能が働くのは頻度は少なくメモリーが少なくなっていると判断された時行われる。  

### 通常のオブジェクト

.NETだけで完結するオブジェクト。  

### マネージドリソースオブジェクト

.NETのオブジェクトであるがファイルやデータベース、ソケット通信などのリソースも扱うオブジェクト。

### アンマネージドリソースオブジェクト

.NET以外のOSやCOMオブジェクトを扱うオブジェクト。  

### オブジェクトの破棄

Disposeメソッドまたは、ガベージコレクションにより自動実行される。  
Diposeメソッドはオブジェクトの破棄を行っただけのメモリー解放待ち状態にするだけあり、実際のメモリーの解放は  
ガベージコレクションのタイミングで行う。  

### メモリーの解放

オブジェクトの破棄をしたものを実際にガベージコレクションがメモリーから解放する。  

### ファイナライザー

ガベージコレクションによって処理されるタイミングで実行される。 
ガベージコレクションのタイミングによるのでいつ実行されるか分からない。 
オブジェクトの破棄をしたメモリーの解放を行い完全にクリーンにしますがその直前で呼ばれます。  

### デストラクター

ファイナライザーを実装するメソッド。 

<br />

## 2. 通常のオブジェクトの破棄

.NETだけで完結するオブジェクト、つまりファイルやデータベースなど外部リソースを使わないオブジェクトの破棄は  
ガベージコレクションにより使われていないと判断されたものは自動的に破棄されメモリーの解放も行われます。  
`System.String`クラスや、`System.Collections.Generic.List<T>`クラスなどです。  
これらのクラスにはDispose()メソッドは無く明示的に破棄する必要は無い。  

<br />

## 3. マネージドリソースオブジェクトの破棄

.NETだけではなくファイルやデータベース、ソケット通信などの外部リソースも使用するが.NETのクラスでのオブジェクトを指します。  
`System.IO.FileStream`クラスや`System.Data.SqlClient.SqlConnection`クラスなどです。  
これらのクラスは`IDisposable`インターフェースを実装したDispose()、Dispose(bool)メソッドがあります。  
しかし、Disposeメソッドを呼び出さなくても自動でガベージコレクションがいつかはオブジェクトの破棄とメモリーの解放を行ってくれる。  
でもやはり実際は、速やかにオブジェクトの破棄をしファイルなどの資源を他人や再度自分自身が使うために解放しなければなりません。  
この様な場合にDisposeメソッドを呼び出します。または、usingステートメントの終わりで自動でDisposeメソッドを呼び出す方法を使います。  
また、マネージドリソースオブジェクトを使ったクラスでさらにそれをフィールドで使う場合はそのクラスでIDisposeインターフェースを継承し  
Disposeメソッドを実装します。このDisposeメソッドでそれらのオブジェクトの破棄を行います。  
マネージドリソースオブジェクトをフィールドではなくメソッドなどのブロック内でインスタンスを作成する場合はそのメソッド内がスコープ  
なのでそのメソッドを抜けると自動的にDisposeメソッドが呼ばれ破棄されますので必要はありません。  
しかし、usingやDisposeメソッドを呼び出して破棄して置く方が良いでしょう。  
また、マネージドリソースオブジェクトはデストラクターでファイナライザーを呼び出してオブジェクトの破棄をしてはいけない。  
デストラクターおよびファイナライザーはガベージコレクションのタイミングで行われるためタイミングは合わずすでにオブジェクトの破棄を  
行った上にさらにオブジェクトの破棄を行う恐れがあります。  
また、`System.GC.SuppressFinalize(this)`メソッドを呼び出すとデストラクターを呼び出さないようにする事ができます。  
マネージドリソースオブジェクトはIDisposableメソッドを実装しその中でオブジェクトの破棄をしますがデストラクターは呼び出さない方が  
良いのでこのメソッドを書いて置くと良いでしょう。  

### IDisposable

IDisposableの波線の`考えられる修正内容を表示する`で`破棄パターンを使って明示的に実装する`を選んで自動でプログラムの追加を行うと便利。  

```csharp
#region IDisposable Support
  private bool disposedValue = false; // 重複する呼び出しを検出するには

    protected virtual void Dispose(bool disposing)
    {
      if (!disposedValue)
      {
        if (disposing)
        {
          // TODO: マネージ状態を破棄します (マネージ オブジェクト)。
        }
          // TODO: アンマネージ リソース (アンマネージ オブジェクト) を解放し、下のファイナライザーをオーバーライドします。
          // TODO: 大きなフィールドを null に設定します。
          disposedValue = true;
      }
    }

    // TODO: 上の Dispose(bool disposing) にアンマネージ リソースを解放するコードが含まれる場合にのみ、ファイナライザーをオーバーライドします。
    // ~FileOperation()
    // {
    //   // このコードを変更しないでください。クリーンアップ コードを上の Dispose(bool disposing) に記述します。
    //   Dispose(false);
    // }

    // このコードは、破棄可能なパターンを正しく実装できるように追加されました。
    void IDisposable.Dispose()
    {
      // このコードを変更しないでください。クリーンアップ コードを上の Dispose(bool disposing) に記述します。
      Dispose(true);
      // TODO: 上のファイナライザーがオーバーライドされる場合は、次の行のコメントを解除してください。
      // GC.SuppressFinalize(this);
    }
#endregion
```

<br />

## 4. アンマネージドリソースオブジェクトの破棄

.NETのクラスではなくWindowsAPIやCOMオブジェクト、ActiveXなどを呼び出した場合作成されるオブジェクトを指します。  
これらは、.NETのようなDisposeメソッドは無くこれらを扱うクラスではマネージドリソースオブジェクトと同じく`IDispose`インタフェースを  
継承しDisposeメソッドを実装しその中で破棄内容を書きます(MarshalReleaseComObjectなど)。  
また、確実に破棄されるか分からないのでこのクラスのデストラクターにも処理を書きます。  
呼び出し元クラスはこのオブジェクトのDisposeメソッドを呼び出しガベージコレクションによりデストラクターでも処理させます。

<br />

* * *
